---
title: OSCamp D7-rCore Chapter 2&3
date: 2024-04-14 09:43:47
tags: [Rust, RISC-V]
category: [OSCamp]
---
之前错把22年的资料拿来学了，这里开始回到2024S的主线。

新版资料第二章没有练习，所以第二和第三章就一起记录了。作业内容不会放到文档里。

下面两张图分别是：
* 三个任务按顺序切换的示意图
* 包括任务上下文的切换

{% asset_img task_context_switch.png 任务切换 %}
{% asset_img task_swich_complete.png 任务上下文的切换 %}

<!--more-->

# 基础：陷入、异常、中断
这三个词语和概念是必须搞清楚的，否则没办法继续。他们的英文原词对应如下：
* 陷入(trap)
* 异常(exception)
* 中断(interrupt)

三者并不是平行关系，也不是包含关系，但是确实有因果关系。以下内容仅在常见的M-S-U模型下讨论，且主要关注S模式和U模式，对于更复杂的例如支持N-extension的平台可能有特殊情况。此外也假设`medeleg`和`mideleg`已经被SBI设置，这和教程的条件相同。

这些条件的含义请参见spec文档，当然如果只是要满足课程内容应该用不上。

## trap
首先是陷入(trap)。这个词有时候在中文里也称为中断，跟语境有关，所以总是导致混淆。为了区分我们之后尽量用英文原文。

trap指的是CPU在执行指令时被打断，有两种子情况，分别在后面两节描述。trap发生时当前程序计数器寄存器(`pc`)的值被保存到`sepc`中，例如：

* U模式发生trap，`pc`保存到`sepc`，设置`sstatus.SPP=0`，进入S模式。
* S模式发生trap，`pc`保存到`sepc`，设置`sstatus.SPP=1`，同样进入S模式。

trap发生时以上的寄存器之一会保存发生时的`pc`，然后立刻把`pc`的值设置为预先设定好的**trap处理程序的地址**，即`stvec`寄存器高62位。

`pc`被设置后CPU下一个指令周期就会从该处开始执行。注意！trap发生时权限就已经切换，例如U模式进入S模式的trap处理程序就运行在S模式。

当trap处理程序运行完毕后，会通过指令`sret`跳转回到trap发生前的地址，即`sret`会把前面保存的`sepc`恢复到`pc`中。同时`sret`也会切换权限等级，例如
* 在`sstatus.SPP=0`时，进入U模式。
* 在`sstatus.SPP=1`时，进入S模式，同时设置`sstatus.SPP=0`。

根据前文的讨论，有两种情况：
* U模式trap进入S模式时`sstatus.SPP=0`，除非被更改，之后`sret`会回到U模式。
* S模式trap进入S模式时`sstatus.SPP=1`，除非被更改，之后`sret`仍然回到S模式。

而trap处理程序的一个很重要方面是**保存和恢复执行前后的寄存器状态**，执行前后寄存器状态不应有区别，完整的trap处理对发生trap的位置来说应该是完全无法感知的。

## exception
异常(exception)指的是由被执行的指令**同步**触发的不常见的状况，例如程序执行的非法的指令，或者读取了非法的地址，甚至是一条syscall。

**每次**exception发生时立刻在导致exception的指令处发生trap，即发生上一小节描述的情况。**没有例外**。

## interrupt
中断(interrupt)指的是一种**异步**发生的不常见的状况，一般不由某些固定指令触发，当然也有例外，例如software interrupt就是通过设置某些寄存器位来触发。interrupt的一个典型例子是时钟中断，即timer interrupt，会根据寄存器`xtime`和`xtimecmp`的值来触发。

interrupt触发trap的条件如下

1. U模式到S模式：`sie`和`sip`的对应位都为1。`sie`的位表示对应中断是否可用，为0则中断永远不会触发trap。sip的位表示当前中断是否需要处理，例如在`stime`大于或等于`stimecmp`时`sip.STIP`被设置为1。
2. S模式到S模式：除1以外，还需要保证`sstatus.SIE`设置为1。

实际上因为U模式比S模式权限等级低，所以在U模式下`status.SIE`的值不会影响触发trap。

如果要屏蔽某种类型的中断，只需要把`sie`寄存器的某些位清除即可。

# 第二章：批处理系统
第二章是第三章的基础，第二章内容有两点：

1. 按顺序加载程序并执行
2. 进入U模式

## 按顺序加载程序

即批处理系统的特点，操作系统一次只加载一个U模式程序(用户程序)到内存，位置固定(0x80400000)，且程序的大小不能超出某个值(0x20000)，其他程序必须等待第一个程序执行完毕或出错结束后才能开始执行，执行下一个程序会覆盖前一个程序的内存空间。

## U模式的trap

在开始执行用户态程序之前必须设置`stvec`寄存器的高62位为中断(trap)处理程序的地址(教程中为`__alltraps`)，低2位为0(即DIRECT模式)。

* DIRECT模式是指无论trap由interrupt触发还是由exception触发，都直接跳转至设置的地址。
* 此外还有VECTORED模式，该模式对exception是直接跳转，但会根据interrupt的类型计算跳转的偏移(`+4*cause`)，具体请见RISC-V官方文档。

因为一次只执行一个程序，所以只有一个内核栈和一个用户栈。当用户程序发生trap进入S模式时，跳转至trap处理程序(`__alltraps`)。

trap处理程序会立刻从用户栈切换为内核栈，在内核栈上执行一系列保存现场的代码，并跳转至真正的trap分派函数，即教程中的trap_handler函数。

该函数会根据中断的类型执行不同的操作，例如8号异常表示由一条U态的`ecall`指令触发，这说明用户程序向内核请求一条syscall，此时内核应该响应请求并返回结果。

当trap分派结束后，中断处理程序恢复此前保存的状态，然后从内核栈切换为用户栈，执行`sret`，该指令从S模式恢复到U模式。


## 进入U模式
前面只说了S模式和U模式之间的转换，但是第一次进入U模式的过程有些许特别。程序会在内核栈顶部存入第一个程序的`TrapContext`，然后调用trap处理程序的后半段，即`__restore(ctx: *const TrapContext)`从而"恢复"至U模式。

为了做到这一点，在内核栈压入的第一个`TrapContext`必须满足如下条件：
* 保存的`sstatus.SPP`为0，即**假装之前的模式是U模式**，因此`__restore`最后的`sret`指令才能"回到"U模式。
* 保存的`sepc`是程序的入口点，即**假装之前从程序的入口点trap过来**，因此才能"回到"入口点。
* 保存的`sp`为用户栈的栈顶。
* 其他寄存器全部为0，当然更复杂的情况下也可以用寄存器传递一些参数给程序入口点。

注意！以上流程运行在boot栈上，第一次调用的`_restore`的三条指令
```
_restore:
    mv sp, a0
    ...
    addi sp, sp, 34*8
    csrrw sp, sscratch, sp
```
会把内核栈顶换到`sscratch`上，因为`a0`指向内核栈上的`TrapContext`对象。

从此之后的所有执行栈切换全部都在内核栈和用户栈上，boot栈不再使用。

## 执行下一个程序
程序执行完毕或出错导致提前结束后，控制权返回S模式，此时运行在在**内核栈**上，找到下一个程序，在内核栈顶压入下一个程序的`TrapContext`，执行和上一小节类似的行为，唯一的区别在于此时已经不在boot栈上执行。

# 第三章：多道程序与分时多任务
与第二章的批处理系统不同，第三章主要是如下两个方面：

* 多道程序：一次性加载多个任务到内存的不同位置，并且在这些任务之间切换，例如通过`sys_yield`来主动切换，或者
* 分时多任务：由内核通过时钟中断来定期切换任务，使任务"同时"进行。

注意这里的"同时"一词并不是真正意义上的同一时刻，而是指操作系统不会过分偏袒某个程序为其分配过多的CPU时间。

让程序在多个任务之间切换的原因在于，某些任务可能需要等待某些需要较长时间的操作，如IO访问，通常速度比CPU的指令执行要慢上几个数量级，与其原地等待不如把CPU让出去给其他可执行的任务。

另外"程序"和"任务"的含义并不相同：
* 程序：可执行代码和数据的集合。
* 任务：供操作系统调度的单元。

一般操作系统都能支持把同一个程序"同时"运行多次。由于教程中所有程序都被静态加载，且执行刚好一次，所以也可以把这两个词语稍微混用，不影响结论。

分时多任务只是多道程序的一个扩展，所以接下来重点放在多道程序的实现。

## 任务切换
操作系统首先把所有程序都加载到内存，为每个任务分配一个属性`status`表示它的状态：
* UnInit：已加载但未初始化
* Ready：初始化完成，表示它随时可以被调度
* Running：当前正在运行
* Exited：运行已经结束

和第二章不同的是，因为多个任务"同时"进行，所以每个任务都需要一个用户栈，和对应的内核栈。

U模式的任务不能直接切换到其他任务，**任务之间的切换必须在内核态完成**，例如教程中的一个syscall函数`sys_yield`会进入S模式，它的作用是从当前任务主动让出，切换到其他任务上执行，而任务必须从S模式切入。

用户栈与内核栈之间的切换在第二章已经实现，所以这里只需要实现**任务的内核栈之间切换**即可。


## 任务上下文
每个任务都有全局、静态、唯一的一个`TaskControlBlock`，其中有一个类型为`TaskContext`的字段，也就是**任务上下文**。要在任务之间切换，必须保存当前任务的上下文以便下次切换回来时恢复。

**任务切换**与**内核栈和用户栈之间切换**完全不是一个层次的概念。我非常担心读者会把`TaskContext`和第二章的`TrapContext`搞混，所以这一节我会尽可能细致的讲解，希望读者能深入思考并在脑海中模拟出**从一个任务的用户态切换到另一个任务的用户态**的所有细节。

`TaskContext`共有三个字段：

1. `ra: usize`，保存下次调度时开始执行的地址，在内核态，也就是`run_next_task`的最后(除了第一个任务以外，后面会说)。
2. `sp: usize`，保存任务内核栈的`sp`，下次被调度时必须恢复。
3. `s: [usize; 12]`，保存`s0`到`s11`的寄存器，连同上面的`sp`一起的这些寄存器叫做callee-saved，所以从Rust调用时它们不会被调用方保存，必须手动保存。

切换函数是`__switch(current: *mut TaskContext, next: *const TaskContext)`
* 参数`current`是当前任务的`TaskContext`可变指针，该函数把对应的寄存器复制到其中，然后
* 把`next`中保存的复制到对应寄存器中，然后通过`ret`指令跳转到到恢复的`ra`去。

第二步跳转到的`ra`即是之前保存的，也就是`run_next_task`的最后，这时站在被恢复的任务的角度来看，相当于调用的`__switch`函数返回了，然后经过层层返回，包括trap的返回，该任务的`sys_yield`也返回了，最终回到用户态执行，仿佛切换没有发生过。

在继续之前，希望读者能想清楚这两点：
> `TaskContext`保存的是内核态的上下文，是为了在(不同任务的)内核栈之间切换而保存。  
> `TrapContext`保存的是用户态的上下文，是为了处理用户态trap而保存。

## 第一次调度
所有任务的第一次调度也是通过`__switch`函数完成的，区别只是此时的`next`参数稍微有些特别。

前文已经说过，每个任务都有全局、静态、唯一的一个`TaskControlBlock`，它的`task_cx: TaskContext`字段也是静态初始化的，由于它还没有被调度过，所以其中并不是被保存的上下文，而是程序的初始上下文：
1. `ra`设置为`__restore`，第三章的`__restore`和第二章有很重要的区别，下面会说。
2. `sp`设置为内核栈压入的`TrapContext`地址，`TrapContext`的初始化和第二章相同。
3. `s`全部初始化为0，会被`__restore`覆盖，所以也可以随便填。

第三章的`__restore`相比于第二章少了第一条指令`mv sp, a0`，因此不需要任何参数。

如此，任务第一次被调度时，`__switch`函数就会把`sp`寄存器设置为内核栈压入的`TrapContext`地址，然后把`ra`寄存器设置为`__restore`，跳转到`__restore`。

紧接着，`__restore`把内核栈的`TrapContext`弹出，`sp`寄存器回到内核栈顶，按照第二章的机制跳转到程序入口点。

## 第一个任务
一般情况下任务的切换都在前一个任务的内核栈上完成，那么怎么调度第一个任务呢？换言之，`__switch`函数第一次调用时，它的第一个参数传什么？

请参见`src/task/mod.rs`的`run_first_task`函数，该函数被boot入口点`rust_main`调用，因此运行在boot栈上，它在boot栈上创建一个空的`_unused: TaskContext`，把它的指针作为参数传入第一个`__switch`表示"当前任务"。但`_unused`不在`TaskManager`中，所以不会被其他任务调度。

## 分时多任务
以上的任务切换机制只能希望任务之间能主动礼让，分时多任务则规定了任务最长能占有多少CPU时间，超出规定时间就切换到下一个任务，当然用户程序也可以主动yield提前结束自己的时间片。

机制十分简单：
1. 在内核态启用时钟中断并设置超时，然后开始执行任务。
2. 时钟中断触发时重置超时，并切换至下一个任务。

不过原有代码似乎有点缺陷：任务主动yield之后不会重置超时，导致下一个任务会过早被时钟中断打断。
